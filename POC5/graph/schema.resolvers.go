package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"bookapp/graph/model"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"sync"

	"github.com/segmentio/kafka-go"
)

type Book struct {
	ID     string `json:"id"`
	Title  string `json:"title"`
	Author string `json:"author"`
	Review string `json:"review"`
}

var books []*model.Book
var mutex sync.Mutex
var producer *kafka.Writer

func init() {

	// Kafka producer configuration
	brokers := []string{"localhost:9092"}

	config := kafka.WriterConfig{
		Brokers:  brokers,
		Topic:    "crud-events",
		Balancer: &kafka.LeastBytes{},
	}

	producer = kafka.NewWriter(config)

	file, err := os.Open("data.json")
	if err != nil {
		fmt.Println(err)
	}
	defer file.Close()

	data, err := ioutil.ReadAll(file)
	if err != nil {
		panic(err)
	}

	err = json.Unmarshal(data, &books)
	if err != nil {
		panic(err)
	}
	fmt.Println("loaded book", books)
}

// CreateBook is the resolver for the createBook field.
func (r *mutationResolver) CreateBook(ctx context.Context, input model.BookInput) (*model.Book, error) {
	mutex.Lock()
	defer mutex.Unlock()

	id := generateID()

	newBook := &model.Book{
		ID:     &id,
		Title:  input.Title,
		Author: input.Author,
		Review: input.Review,
	}

	books = append(books, newBook)
	saveBooksToFile()

	newBookJSON, err := json.Marshal(newBook)
	if err != nil {
		return nil, err
	}

	message := kafka.Message{
		Key: []byte(*newBook.ID),
		Value: []byte(fmt.Sprintf(`{
			"OPERATION": "CREATE",
			"DATA": %s
		}`, newBookJSON)),
	}

	err = producer.WriteMessages(ctx, message)
	if err != nil {
		return nil, err
	}

	return newBook, nil
}

// UpdateBook is the resolver for the updateBook field.
func (r *mutationResolver) UpdateBook(ctx context.Context, id string, input model.BookInput) (*model.Book, error) {
	mutex.Lock()
	defer mutex.Unlock()

	for _, book := range books {
		if *book.ID == id {
			book.Title = input.Title
			book.Author = input.Author
			book.Review = input.Review

			saveBooksToFile()

			updatedBook, err := json.Marshal(book)
			if err != nil {
				return nil, err
			}

			message := kafka.Message{
				Key: []byte(*book.ID),
				Value: []byte(fmt.Sprintf(`{
					"OPERATION": "UPDATE",
					"DATA": %s
				}`, updatedBook)),
			}

			err = producer.WriteMessages(ctx, message)
			if err != nil {
				return nil, err
			}
			return book, nil
		}
	}

	return nil, fmt.Errorf("book with ID %s not found", id)
}

// DeleteBook is the resolver for the deleteBook field.
func (r *mutationResolver) DeleteBook(ctx context.Context, id string) (*bool, error) {
	mutex.Lock()
	defer mutex.Unlock()

	for i, book := range books {
		if *book.ID == id {
			books = append(books[:i], books[i+1:]...)
			saveBooksToFile()
			deleted := true

			deletedBook, err := json.Marshal(book)
			if err != nil {
				return nil, err
			}

			message := kafka.Message{
				Key: []byte(*book.ID),
				Value: []byte(fmt.Sprintf(`{
					"OPERATION": "DELETE",
					"DATA": %s
				}`, deletedBook)),
			}

			err = producer.WriteMessages(ctx, message)
			if err != nil {
				return nil, err
			}

			return &deleted, nil
		}
	}
	deleted := false

	return &deleted, fmt.Errorf("book with ID %s not found", id)
}

// Books is the resolver for the books field.
func (r *queryResolver) Books(ctx context.Context) ([]*model.Book, error) {
	mutex.Lock()
	defer mutex.Unlock()

	message := kafka.Message{
		Value: []byte(fmt.Sprintf(`{
			"OPERATION": "READ",
			"DATA": "ALL RECORDS"
		}`)),
	}

	err := producer.WriteMessages(ctx, message)
	if err != nil {
		return nil, err
	}

	return books, nil
}

// Book is the resolver for the book field.
func (r *queryResolver) Book(ctx context.Context, id string) (*model.Book, error) {
	mutex.Lock()
	defer mutex.Unlock()

	fmt.Println("book", books)
	for _, book := range books {
		fmt.Println("Booke ID: ", book, "Given ID :", id)
		if *book.ID == id {

			readBook, err := json.Marshal(book)
			if err != nil {
				return nil, err
			}

			message := kafka.Message{
				Key: []byte(*book.ID),
				Value: []byte(fmt.Sprintf(`{
					"OPERATION": "READ",
					"DATA": %s
				}`, readBook)),
			}

			err = producer.WriteMessages(ctx, message)
			if err != nil {
				return nil, err
			}
			return book, nil
		}
	}
	return nil, fmt.Errorf("book with ID %s not found", id)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

func generateID() string {
	return "ID_" + strconv.Itoa(len(books)+1)
}

func saveBooksToFile() {
	data, err := json.MarshalIndent(books, "", "  ")
	if err != nil {
		panic(err)
	}

	err = ioutil.WriteFile("data.json", data, 0644)
	if err != nil {
		panic(err)
	}
}
